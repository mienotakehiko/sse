Linear part: No equation.
Convergent part:
dec(enc(x,k),k) = x
divideB(con(x,n)) = x
Completing equations...
Completed equations:
divideB(con(x,n)) = x
dec(enc(x,k),k) = x
Process 0 (that is, the initial process):
(
    {1}let w: bitstring = w3 in
    {2}out(ch, maketrap(con(w,1),k1));
    {3}out(ch, maketrap(con(w,2),k1));
    {4}out(ch, maketrap(con(w,3),k1));
    {5}out(ch, maketrap(con(w,4),k1));
    {6}in(ch, C: bitstring);
    {7}let d: bitstring = dec(C,k2) in
    {8}if (d = m1) then
        {9}event SUCCESS1
    else
        {10}if (d = m2) then
            {11}event SUCCESS2
        else
            {12}if (d = m3) then
                {13}event SUCCESS3
            else
                {14}if (d = m4) then
                {15}event SUCCESS4
) | (
    {16}in(ch, tw: trapdoor);
    {19}get Index(=tw,id: nat) in
    {18}get angouID(=id,c: bitstring) in
    {17}out(ch, c)
) | (
    {20}insert angouID(1,enc(m1,k2));
    {21}insert angouID(2,enc(m2,k2));
    {22}insert angouID(3,enc(m3,k2));
    {23}insert angouID(4,enc(m4,k2));
    {24}insert angouID(5,enc(m5,k2));
    {25}insert Index(maketrap(con(w1,1),k1),1);
    {26}insert Index(maketrap(con(w1,6),k1),2);
    {27}insert Index(maketrap(con(w1,2),k1),5);
    {28}insert Index(maketrap(con(w1,3),k1),3);
    {29}insert Index(maketrap(con(w1,4),k1),4);
    {30}insert Index(maketrap(con(w2,1),k1),1);
    {31}insert Index(maketrap(con(w2,2),k1),2);
    {32}insert Index(maketrap(con(w2,7),k1),3);
    {33}insert Index(maketrap(con(w2,3),k1),5);
    {34}insert Index(maketrap(con(w2,8),k1),4);
    {35}insert Index(maketrap(con(w2,4),k1),5);
    {36}insert Index(maketrap(con(w3,1),k1),1);
    {37}insert Index(maketrap(con(w3,6),k1),2);
    {38}insert Index(maketrap(con(w3,2),k1),5);
    {39}insert Index(maketrap(con(w3,3),k1),3);
    {40}insert Index(maketrap(con(w3,8),k1),4);
    {41}insert Index(maketrap(con(w3,4),k1),5);
    {42}insert Index(maketrap(con(w4,1),k1),5);
    {43}insert Index(maketrap(con(w4,2),k1),5);
    {44}insert Index(maketrap(con(w4,3),k1),5);
    {45}insert Index(maketrap(con(w4,4),k1),5);
    {46}insert Index(maketrap(con(w5,1),k1),5);
    {47}insert Index(maketrap(con(w5,2),k1),5);
    {48}insert Index(maketrap(con(w5,3),k1),5);
    {49}insert Index(maketrap(con(w5,4),k1),5)
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}let w: bitstring = w3 in
    {2}out(ch, maketrap(con(w,1),k1));
    {3}out(ch, maketrap(con(w,2),k1));
    {4}out(ch, maketrap(con(w,3),k1));
    {5}out(ch, maketrap(con(w,4),k1));
    {6}in(ch, C: bitstring);
    {7}let d: bitstring = dec(C,k2) in
    {8}if (d = m1) then
        {9}event SUCCESS1
    else
        {10}if (d = m2) then
            {11}event SUCCESS2
        else
            {12}if (d = m3) then
                {13}event SUCCESS3
            else
                {14}if (d = m4) then
                {15}event SUCCESS4
) | (
    {16}in(ch, tw: trapdoor);
    {19}get Index(=tw,id: nat) in
    {18}get angouID(=id,c: bitstring) in
    {17}out(ch, c)
) | (
    {20}insert angouID(1,enc(m1,k2));
    {21}insert angouID(2,enc(m2,k2));
    {22}insert angouID(3,enc(m3,k2));
    {23}insert angouID(4,enc(m4,k2));
    {24}insert angouID(5,enc(m5,k2));
    {25}insert Index(maketrap(con(w1,1),k1),1);
    {26}insert Index(maketrap(con(w1,6),k1),2);
    {27}insert Index(maketrap(con(w1,2),k1),5);
    {28}insert Index(maketrap(con(w1,3),k1),3);
    {29}insert Index(maketrap(con(w1,4),k1),4);
    {30}insert Index(maketrap(con(w2,1),k1),1);
    {31}insert Index(maketrap(con(w2,2),k1),2);
    {32}insert Index(maketrap(con(w2,7),k1),3);
    {33}insert Index(maketrap(con(w2,3),k1),5);
    {34}insert Index(maketrap(con(w2,8),k1),4);
    {35}insert Index(maketrap(con(w2,4),k1),5);
    {36}insert Index(maketrap(con(w3,1),k1),1);
    {37}insert Index(maketrap(con(w3,6),k1),2);
    {38}insert Index(maketrap(con(w3,2),k1),5);
    {39}insert Index(maketrap(con(w3,3),k1),3);
    {40}insert Index(maketrap(con(w3,8),k1),4);
    {41}insert Index(maketrap(con(w3,4),k1),5);
    {42}insert Index(maketrap(con(w4,1),k1),5);
    {43}insert Index(maketrap(con(w4,2),k1),5);
    {44}insert Index(maketrap(con(w4,3),k1),5);
    {45}insert Index(maketrap(con(w4,4),k1),5);
    {46}insert Index(maketrap(con(w5,1),k1),5);
    {47}insert Index(maketrap(con(w5,2),k1),5);
    {48}insert Index(maketrap(con(w5,3),k1),5);
    {49}insert Index(maketrap(con(w5,4),k1),5)
)

-- Query not attacker(m1[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(m1[])
RESULT not attacker(m1[]) is true.
-- Query not attacker(m2[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(m2[])
RESULT not attacker(m2[]) is true.
-- Query not attacker(m3[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(m3[])
RESULT not attacker(m3[]) is true.
-- Query not attacker(m4[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(m4[])
RESULT not attacker(m4[]) is true.
-- Query not attacker(w1) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(w1)
RESULT not attacker(w1) is true.
-- Query not attacker(w2) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(w2)
RESULT not attacker(w2) is true.
-- Query not attacker(w3[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(w3[])
RESULT not attacker(w3[]) is true.
-- Non-interference w3 in process 1.
Warning: using "noninterf" in the presence of equations may yield many
false attacks. If you observe false attacks, try to code the desired
property using "choice" instead.
Translating the process into Horn clauses...
Completing...
goal reachable: bad

Derivation:

1. The message maketrap(con(w3[],1),k1[]) may be sent to the attacker at output {2}.
attacker(maketrap(con(w3[],1),k1[])).

2. The entry Index(maketrap(con(w1,1),k1[]),1) may be inserted in a table at insert {25}.
table(Index(maketrap(con(w1,1),k1[]),1)).

3. The message maketrap(con(w3[],1),k1[]) that the attacker may have by 1 may be received at input {16}.
The entry Index(maketrap(con(w1,1),k1[]),1) that may be in a table by 2 may be read at get {19}.
The terms (true,Index(maketrap(con(w3[],1),k1[]),@gen),maketrap(con(w3[],1),k1[])) and (@gen_1,Index(maketrap(con(w1,1),k1[]),1),@gen_2) unify for some values of the secrets and not for others.
So the attacker can make a distinguishing test at {19}.
bad.


Could not find a trace corresponding to this derivation.
RESULT Non-interference w3 cannot be proved.
-- Weak secret w3 in process 1.
Translating the process into Horn clauses...
Termination warning: v ≠ v_1 && attacker_guess(v_2,v) && attacker_guess(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker_guess(v,v_2) && attacker_guess(v_1,v_2) -> bad
Selecting 0
Completing...
Termination warning: v ≠ v_1 && attacker_guess(v_2,v) && attacker_guess(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker_guess(v,v_2) && attacker_guess(v_1,v_2) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker(v) && attacker_guess(v,v_1) -> bad
Selecting 1
Termination warning: v ≠ v_1 && attacker(v) && attacker_guess(v_1,v) -> bad
Selecting 1
RESULT Weak secret w3 is true.
-- Query not event(SUCCESS1) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not event(SUCCESS1)
goal reachable: event(SUCCESS1)

Derivation:

1. The message maketrap(con(w3[],1),k1[]) may be sent to the attacker at output {2}.
attacker(maketrap(con(w3[],1),k1[])).

2. The entry Index(maketrap(con(w3[],1),k1[]),1) may be inserted in a table at insert {36}.
table(Index(maketrap(con(w3[],1),k1[]),1)).

3. The entry angouID(1,enc(m1[],k2[])) may be inserted in a table at insert {20}.
table(angouID(1,enc(m1[],k2[]))).

4. The message maketrap(con(w3[],1),k1[]) that the attacker may have by 1 may be received at input {16}.
The entry Index(maketrap(con(w3[],1),k1[]),1) that may be in a table by 2 may be read at get {19}.
The entry angouID(1,enc(m1[],k2[])) that may be in a table by 3 may be read at get {18}.
So the message enc(m1[],k2[]) may be sent to the attacker at output {17}.
attacker(enc(m1[],k2[])).

5. The message enc(m1[],k2[]) that the attacker may have by 4 may be received at input {6}.
So event SUCCESS1 may be executed at {9}.
event(SUCCESS1).

6. By 5, event(SUCCESS1).
The goal is reached, represented in the following fact:
event(SUCCESS1).


Initial state

Additional knowledge of the attacker:
ch
--------------------------------------------------------------
New processes:
    (
        let w: bitstring = w3 in
        out(ch, maketrap(con(w,1),k1));
        out(ch, maketrap(con(w,2),k1));
        out(ch, maketrap(con(w,3),k1));
        out(ch, maketrap(con(w,4),k1));
        in(ch, C: bitstring);
        let d: bitstring = dec(C,k2) in
        if (d = m1) then
            event SUCCESS1
        else
            if (d = m2) then
                event SUCCESS2
            else
                if (d = m3) then
                    event SUCCESS3
                else
                    if (d = m4) then
                    event SUCCESS4
    ) | (
        in(ch, tw: trapdoor);
        get Index(=tw,id: nat) in
        get angouID(=id,c: bitstring) in
        out(ch, c)
    ) | (
        insert angouID(1,enc(m1,k2));
        insert angouID(2,enc(m2,k2));
        insert angouID(3,enc(m3,k2));
        insert angouID(4,enc(m4,k2));
        insert angouID(5,enc(m5,k2));
        insert Index(maketrap(con(w1,1),k1),1);
        insert Index(maketrap(con(w1,6),k1),2);
        insert Index(maketrap(con(w1,2),k1),5);
        insert Index(maketrap(con(w1,3),k1),3);
        insert Index(maketrap(con(w1,4),k1),4);
        insert Index(maketrap(con(w2,1),k1),1);
        insert Index(maketrap(con(w2,2),k1),2);
        insert Index(maketrap(con(w2,7),k1),3);
        insert Index(maketrap(con(w2,3),k1),5);
        insert Index(maketrap(con(w2,8),k1),4);
        insert Index(maketrap(con(w2,4),k1),5);
        insert Index(maketrap(con(w3,1),k1),1);
        insert Index(maketrap(con(w3,6),k1),2);
        insert Index(maketrap(con(w3,2),k1),5);
        insert Index(maketrap(con(w3,3),k1),3);
        insert Index(maketrap(con(w3,8),k1),4);
        insert Index(maketrap(con(w3,4),k1),5);
        insert Index(maketrap(con(w4,1),k1),5);
        insert Index(maketrap(con(w4,2),k1),5);
        insert Index(maketrap(con(w4,3),k1),5);
        insert Index(maketrap(con(w4,4),k1),5);
        insert Index(maketrap(con(w5,1),k1),5);
        insert Index(maketrap(con(w5,2),k1),5);
        insert Index(maketrap(con(w5,3),k1),5);
        insert Index(maketrap(con(w5,4),k1),5)
    )

--------------------------------------------------------------
1st process: Reduction |

2nd process: Reduction |

3rd process: Beginning of process Indexprocess

3rd process: insert angouID(1,enc(m1,k2)) done

3rd process: insert angouID(2,enc(m2,k2)) done

3rd process: insert angouID(3,enc(m3,k2)) done

3rd process: insert angouID(4,enc(m4,k2)) done

3rd process: insert angouID(5,enc(m5,k2)) done

3rd process: insert Index(maketrap(con(w1,1),k1),1) done

3rd process: insert Index(maketrap(con(w1,6),k1),2) done

3rd process: insert Index(maketrap(con(w1,2),k1),5) done

3rd process: insert Index(maketrap(con(w1,3),k1),3) done

3rd process: insert Index(maketrap(con(w1,4),k1),4) done

3rd process: insert Index(maketrap(con(w2,1),k1),1) done

3rd process: insert Index(maketrap(con(w2,2),k1),2) done

3rd process: insert Index(maketrap(con(w2,7),k1),3) done

3rd process: insert Index(maketrap(con(w2,3),k1),5) done

3rd process: insert Index(maketrap(con(w2,8),k1),4) done

3rd process: insert Index(maketrap(con(w2,4),k1),5) done

3rd process: insert Index(maketrap(con(w3,1),k1),1) done

3rd process: insert Index(maketrap(con(w3,6),k1),2) done

3rd process: insert Index(maketrap(con(w3,2),k1),5) done

3rd process: insert Index(maketrap(con(w3,3),k1),3) done

3rd process: insert Index(maketrap(con(w3,8),k1),4) done

3rd process: insert Index(maketrap(con(w3,4),k1),5) done

3rd process: insert Index(maketrap(con(w4,1),k1),5) done

3rd process: insert Index(maketrap(con(w4,2),k1),5) done

3rd process: insert Index(maketrap(con(w4,3),k1),5) done

3rd process: insert Index(maketrap(con(w4,4),k1),5) done

3rd process: insert Index(maketrap(con(w5,1),k1),5) done

3rd process: insert Index(maketrap(con(w5,2),k1),5) done

3rd process: insert Index(maketrap(con(w5,3),k1),5) done

3rd process: insert Index(maketrap(con(w5,4),k1),5) done

3rd process: Reduction 0

2nd process: Beginning of process Serverprocess

1st process: Beginning of process Clientprocess

1st process: let w: bitstring = w3 succeeds

1st process: out(ch, ~M) with ~M = maketrap(con(w3,1),k1) done

Additional knowledge of the attacker:
~M = maketrap(con(w3,1),k1)
--------------------------------------------------------------
1st process: out(ch, ~M_1) with ~M_1 = maketrap(con(w3,2),k1) done

Additional knowledge of the attacker:
~M_1 = maketrap(con(w3,2),k1)
--------------------------------------------------------------
1st process: out(ch, ~M_2) with ~M_2 = maketrap(con(w3,3),k1) done

Additional knowledge of the attacker:
~M_2 = maketrap(con(w3,3),k1)
--------------------------------------------------------------
1st process: out(ch, ~M_3) with ~M_3 = maketrap(con(w3,4),k1) done

Additional knowledge of the attacker:
~M_3 = maketrap(con(w3,4),k1)
--------------------------------------------------------------
New processes:
(
    in(ch, C: bitstring);
    let d: bitstring = dec(C,k2) in
    if (d = m1) then
        event SUCCESS1
    else
        if (d = m2) then
            event SUCCESS2
        else
            if (d = m3) then
                event SUCCESS3
            else
                if (d = m4) then
                event SUCCESS4
) | (
    in(ch, tw: trapdoor);
    get Index(=tw,id: nat) in
    get angouID(=id,c: bitstring) in
    out(ch, c)
)

--------------------------------------------------------------
2nd process: in(ch, tw: trapdoor) done with message ~M = maketrap(con(w3,1),k1)

2nd process: get Index(=maketrap(con(w3,1),k1),id: nat) done with entry Index(maketrap(con(w3,1),k1),1)

2nd process: get angouID(=1,c: bitstring) done with entry angouID(1,enc(m1,k2))

2nd process: out(ch, ~M_4) with ~M_4 = enc(m1,k2) done

Additional knowledge of the attacker:
~M_4 = enc(m1,k2)
--------------------------------------------------------------
2nd process: Reduction 0

New processes:
    in(ch, C: bitstring);
    let d: bitstring = dec(C,k2) in
    if (d = m1) then
        event SUCCESS1
    else
        if (d = m2) then
            event SUCCESS2
        else
            if (d = m3) then
                event SUCCESS3
            else
                if (d = m4) then
                event SUCCESS4

--------------------------------------------------------------
1st process: in(ch, C: bitstring) done with message ~M_4 = enc(m1,k2)

1st process: let d: bitstring = dec(enc(m1,k2),k2) succeeds

1st process: if (dec(enc(m1,k2),k2) = m1) succeeds

1st process: event SUCCESS1 executed; it is a goal

New processes:
    0

--------------------------------------------------------------
The event SUCCESS1 is executed at {9}.
A trace has been found.
RESULT not event(SUCCESS1) is false.
-- Query not event(SUCCESS2) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not event(SUCCESS2)
RESULT not event(SUCCESS2) is true.
-- Query not event(SUCCESS3) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not event(SUCCESS3)
goal reachable: event(SUCCESS3)

Derivation:

1. The message maketrap(con(w3[],3),k1[]) may be sent to the attacker at output {4}.
attacker(maketrap(con(w3[],3),k1[])).

2. The entry Index(maketrap(con(w3[],3),k1[]),3) may be inserted in a table at insert {39}.
table(Index(maketrap(con(w3[],3),k1[]),3)).

3. The entry angouID(3,enc(m3[],k2[])) may be inserted in a table at insert {22}.
table(angouID(3,enc(m3[],k2[]))).

4. The message maketrap(con(w3[],3),k1[]) that the attacker may have by 1 may be received at input {16}.
The entry Index(maketrap(con(w3[],3),k1[]),3) that may be in a table by 2 may be read at get {19}.
The entry angouID(3,enc(m3[],k2[])) that may be in a table by 3 may be read at get {18}.
So the message enc(m3[],k2[]) may be sent to the attacker at output {17}.
attacker(enc(m3[],k2[])).

5. The message enc(m3[],k2[]) that the attacker may have by 4 may be received at input {6}.
So event SUCCESS3 may be executed at {13}.
event(SUCCESS3).

6. By 5, event(SUCCESS3).
The goal is reached, represented in the following fact:
event(SUCCESS3).


Initial state

Additional knowledge of the attacker:
ch
--------------------------------------------------------------
New processes:
    (
        let w: bitstring = w3 in
        out(ch, maketrap(con(w,1),k1));
        out(ch, maketrap(con(w,2),k1));
        out(ch, maketrap(con(w,3),k1));
        out(ch, maketrap(con(w,4),k1));
        in(ch, C: bitstring);
        let d: bitstring = dec(C,k2) in
        if (d = m1) then
            event SUCCESS1
        else
            if (d = m2) then
                event SUCCESS2
            else
                if (d = m3) then
                    event SUCCESS3
                else
                    if (d = m4) then
                    event SUCCESS4
    ) | (
        in(ch, tw: trapdoor);
        get Index(=tw,id: nat) in
        get angouID(=id,c: bitstring) in
        out(ch, c)
    ) | (
        insert angouID(1,enc(m1,k2));
        insert angouID(2,enc(m2,k2));
        insert angouID(3,enc(m3,k2));
        insert angouID(4,enc(m4,k2));
        insert angouID(5,enc(m5,k2));
        insert Index(maketrap(con(w1,1),k1),1);
        insert Index(maketrap(con(w1,6),k1),2);
        insert Index(maketrap(con(w1,2),k1),5);
        insert Index(maketrap(con(w1,3),k1),3);
        insert Index(maketrap(con(w1,4),k1),4);
        insert Index(maketrap(con(w2,1),k1),1);
        insert Index(maketrap(con(w2,2),k1),2);
        insert Index(maketrap(con(w2,7),k1),3);
        insert Index(maketrap(con(w2,3),k1),5);
        insert Index(maketrap(con(w2,8),k1),4);
        insert Index(maketrap(con(w2,4),k1),5);
        insert Index(maketrap(con(w3,1),k1),1);
        insert Index(maketrap(con(w3,6),k1),2);
        insert Index(maketrap(con(w3,2),k1),5);
        insert Index(maketrap(con(w3,3),k1),3);
        insert Index(maketrap(con(w3,8),k1),4);
        insert Index(maketrap(con(w3,4),k1),5);
        insert Index(maketrap(con(w4,1),k1),5);
        insert Index(maketrap(con(w4,2),k1),5);
        insert Index(maketrap(con(w4,3),k1),5);
        insert Index(maketrap(con(w4,4),k1),5);
        insert Index(maketrap(con(w5,1),k1),5);
        insert Index(maketrap(con(w5,2),k1),5);
        insert Index(maketrap(con(w5,3),k1),5);
        insert Index(maketrap(con(w5,4),k1),5)
    )

--------------------------------------------------------------
1st process: Reduction |

2nd process: Reduction |

3rd process: Beginning of process Indexprocess

3rd process: insert angouID(1,enc(m1,k2)) done

3rd process: insert angouID(2,enc(m2,k2)) done

3rd process: insert angouID(3,enc(m3,k2)) done

3rd process: insert angouID(4,enc(m4,k2)) done

3rd process: insert angouID(5,enc(m5,k2)) done

3rd process: insert Index(maketrap(con(w1,1),k1),1) done

3rd process: insert Index(maketrap(con(w1,6),k1),2) done

3rd process: insert Index(maketrap(con(w1,2),k1),5) done

3rd process: insert Index(maketrap(con(w1,3),k1),3) done

3rd process: insert Index(maketrap(con(w1,4),k1),4) done

3rd process: insert Index(maketrap(con(w2,1),k1),1) done

3rd process: insert Index(maketrap(con(w2,2),k1),2) done

3rd process: insert Index(maketrap(con(w2,7),k1),3) done

3rd process: insert Index(maketrap(con(w2,3),k1),5) done

3rd process: insert Index(maketrap(con(w2,8),k1),4) done

3rd process: insert Index(maketrap(con(w2,4),k1),5) done

3rd process: insert Index(maketrap(con(w3,1),k1),1) done

3rd process: insert Index(maketrap(con(w3,6),k1),2) done

3rd process: insert Index(maketrap(con(w3,2),k1),5) done

3rd process: insert Index(maketrap(con(w3,3),k1),3) done

3rd process: insert Index(maketrap(con(w3,8),k1),4) done

3rd process: insert Index(maketrap(con(w3,4),k1),5) done

3rd process: insert Index(maketrap(con(w4,1),k1),5) done

3rd process: insert Index(maketrap(con(w4,2),k1),5) done

3rd process: insert Index(maketrap(con(w4,3),k1),5) done

3rd process: insert Index(maketrap(con(w4,4),k1),5) done

3rd process: insert Index(maketrap(con(w5,1),k1),5) done

3rd process: insert Index(maketrap(con(w5,2),k1),5) done

3rd process: insert Index(maketrap(con(w5,3),k1),5) done

3rd process: insert Index(maketrap(con(w5,4),k1),5) done

3rd process: Reduction 0

2nd process: Beginning of process Serverprocess

1st process: Beginning of process Clientprocess

1st process: let w: bitstring = w3 succeeds

1st process: out(ch, ~M) with ~M = maketrap(con(w3,1),k1) done

Additional knowledge of the attacker:
~M = maketrap(con(w3,1),k1)
--------------------------------------------------------------
1st process: out(ch, ~M_1) with ~M_1 = maketrap(con(w3,2),k1) done

Additional knowledge of the attacker:
~M_1 = maketrap(con(w3,2),k1)
--------------------------------------------------------------
1st process: out(ch, ~M_2) with ~M_2 = maketrap(con(w3,3),k1) done

Additional knowledge of the attacker:
~M_2 = maketrap(con(w3,3),k1)
--------------------------------------------------------------
1st process: out(ch, ~M_3) with ~M_3 = maketrap(con(w3,4),k1) done

Additional knowledge of the attacker:
~M_3 = maketrap(con(w3,4),k1)
--------------------------------------------------------------
New processes:
(
    in(ch, C: bitstring);
    let d: bitstring = dec(C,k2) in
    if (d = m1) then
        event SUCCESS1
    else
        if (d = m2) then
            event SUCCESS2
        else
            if (d = m3) then
                event SUCCESS3
            else
                if (d = m4) then
                event SUCCESS4
) | (
    in(ch, tw: trapdoor);
    get Index(=tw,id: nat) in
    get angouID(=id,c: bitstring) in
    out(ch, c)
)

--------------------------------------------------------------
2nd process: in(ch, tw: trapdoor) done with message ~M_2 = maketrap(con(w3,3),k1)

2nd process: get Index(=maketrap(con(w3,3),k1),id: nat) done with entry Index(maketrap(con(w3,3),k1),3)

2nd process: get angouID(=3,c: bitstring) done with entry angouID(3,enc(m3,k2))

2nd process: out(ch, ~M_4) with ~M_4 = enc(m3,k2) done

Additional knowledge of the attacker:
~M_4 = enc(m3,k2)
--------------------------------------------------------------
2nd process: Reduction 0

New processes:
    in(ch, C: bitstring);
    let d: bitstring = dec(C,k2) in
    if (d = m1) then
        event SUCCESS1
    else
        if (d = m2) then
            event SUCCESS2
        else
            if (d = m3) then
                event SUCCESS3
            else
                if (d = m4) then
                event SUCCESS4

--------------------------------------------------------------
1st process: in(ch, C: bitstring) done with message ~M_4 = enc(m3,k2)

1st process: let d: bitstring = dec(enc(m3,k2),k2) succeeds

1st process: if (dec(enc(m3,k2),k2) = m1): else branch taken

1st process: if (dec(enc(m3,k2),k2) = m2): else branch taken

1st process: if (dec(enc(m3,k2),k2) = m3) succeeds

1st process: event SUCCESS3 executed; it is a goal

New processes:
    0

--------------------------------------------------------------
The event SUCCESS3 is executed at {13}.
A trace has been found.
RESULT not event(SUCCESS3) is false.
-- Query not event(SUCCESS4) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not event(SUCCESS4)
RESULT not event(SUCCESS4) is true.

--------------------------------------------------------------
Verification summary:

Query not attacker(m1[]) is true.

Query not attacker(m2[]) is true.

Query not attacker(m3[]) is true.

Query not attacker(m4[]) is true.

Query not attacker(w1) is true.

Query not attacker(w2) is true.

Query not attacker(w3[]) is true.

Non-interference w3 cannot be proved.

Weak secret w3 is true.

Query not event(SUCCESS1) is false.

Query not event(SUCCESS2) is true.

Query not event(SUCCESS3) is false.

Query not event(SUCCESS4) is true.

--------------------------------------------------------------

